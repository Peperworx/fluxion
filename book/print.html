<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fluxion</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreward.html"><strong aria-hidden="true">1.</strong> Foreward</a></li><li class="chapter-item expanded "><a href="first_steps.html"><strong aria-hidden="true">2.</strong> First Steps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="actors_and_messages.html"><strong aria-hidden="true">2.1.</strong> Defining Actors and Messages</a></li><li class="chapter-item expanded "><a href="handling_messages.html"><strong aria-hidden="true">2.2.</strong> Handling Messages</a></li></ol></li><li class="chapter-item expanded "><a href="foreign.html"><strong aria-hidden="true">3.</strong> Foreign Messages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fluxion</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreward"><a class="header" href="#foreward">Foreward</a></h1>
<p>Fluxion exists to fulfil a very specific usecase: an actor library that can send messages between systems. How these systems are connected does not alter the behavior of Fluxion, nor should it matter to actors running on a Fluxion system. Fluxion is also different from traditional actor libraries in that it does not provide actors mutable access to themselves, nor does it provide &quot;fire and forget&quot; messages.</p>
<p>Fluxion makes both of these restrictions in the name of performance and extensibility. If Fluxion were to allow actors mutable access to themselves, Fluxion would need to implement a layer of synchronization on top of each actor. This needlessly harms the performance of actors that do not need mutable access. Additionally, actors that do need mutable access to themselves can simply implement their own synchronization where needed. Fluxion doesn't provide &quot;fire and forget&quot; messages, because it would require a dependency on a specific async executor. This is because Fluxion, via <a href="https://github.com/peperworx/slacktor">Slacktor</a>, uses a &quot;simulated messaging&quot; system where raw function calls are used instead of channels. This significantly increases performance. If &quot;fire and forget&quot; messages are required, a user can implement them by spawning a new async task to send the message from.</p>
<p>Importantly, Fluxion is <em>not</em> an actor framework, but an actor <em>library</em>. Fluxion will not force your entire application to be designed following a specific pattern, and can be used as much, or as little as you want.</p>
<p>Due to Fluxion's limited scope and architecture, it tends to be <em>very</em> performant, especially when compared to other actor frameworks. Running the <code>benchmark</code> example (which is designed to test Fluxion's raw performance, not necessarily the performance of the actual actors implemented), Fluxion acheives a throughput of ~60 million messages per second on an intel i5-9400 compiled with release. The equivalent code running on Actix can only handle ~700,000 messages per second.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps"><a class="header" href="#first-steps">First Steps</a></h1>
<p>Lets start by creating a Cargo project (in the current directory) and adding Fluxion:</p>
<pre><code class="language-sh">cargo init project_name
cd project_name
cargo add fluxion
</code></pre>
<p>Fluxion needs to be called from an async context. As Fluxion is executor agnostic, it doesn't matter which library is used.
Here we will be using <a href="https://tokio.rs/">Tokio</a>, although any executor will work:</p>
<pre><code class="language-sh">cargo add tokio --features full
</code></pre>
<p>Next, we need to make the main function async, and import a few helpers from Fluxion, and create the Fluxion system:</p>
<pre><code class="language-rust">use fluxion::Fluxion;

#[tokio::main]
async fn main() {
    // Create the Fluxion system:
    let system = Fluxion::new(&quot;system_id&quot;, ());
}</code></pre>
<p>The above code initializes a Fluxion system with the id &quot;system_id&quot; and the delegate <code>()</code>.</p>
<p>What is a delegate?</p>
<p>A delegate is an external type that provides methods to retrieve <code>MessageSender</code>s, which allow actors to communicate with actors on external systems. The unit type (<code>()</code>) is a simple delegate that always returns that no foreign actor was found. Later in this book, we will explore creating our own simple delegate.</p>
<p>Now that we have a system, we need to add an actor to it, and to do that, we must define an actor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-actors"><a class="header" href="#defining-actors">Defining Actors</a></h1>
<p>Any type that is <code>Send</code>, <code>Sync</code>, and <code>'static</code> can be an actor. Lets go ahead and define a unit struct, and use the <code>actor</code> macro to implement the <code>Actor</code> trait automatically.</p>
<pre><code class="language-rust">use fluxion::actor;

#[actor]
struct MyActor;</code></pre>
<h2 id="adding-the-actor-to-the-system"><a class="header" href="#adding-the-actor-to-the-system">Adding the Actor to the System</a></h2>
<p>Adding actors to the system is rather simple:</p>
<pre><code class="language-rust">let id = system.add(MyActor).await.unwrap();</code></pre>
<p>This runs the actor's initialization method, adds the actor to the system, and returns the actor's ID.</p>
<p>The actor's ID can be used to retrieve a reference to the actor from the system. There are two ways to retrieve an actor from the system: <code>get</code> and <code>get_local</code>. We will take a look at <code>get_local</code> first:</p>
<pre><code class="language-rust">let actor_ref = system.get_local::&lt;MyActor&gt;(id).await.unwrap();</code></pre>
<p>The <code>get_local</code> method requires only the actor's type and ID, and returns a concrete type that depends on the actor's type. This allows a single actor reference to send any message that the actor implements, however, this message must reside on the local system.</p>
<p><code>get</code>, on the other hand, enables foreign messages, but also requires that the message type is specified. The returned type, however, is abstracted over handlers of the message type.</p>
<p>To use <code>get</code>, we must first define a message type.</p>
<h1 id="defining-messages"><a class="header" href="#defining-messages">Defining Messages</a></h1>
<p>Messages have similar requirements to actors, and we can use a macro to define them as well:</p>
<pre><code class="language-rust">#[message(())]
struct MyMessage;</code></pre>
<p>The above code defines <code>MyMessage</code> as a message with the response type <code>()</code>.
Messages also each have an ID, which we can optionally set:</p>
<pre><code class="language-rust">#[message((), &quot;my_message&quot;)]
struct MyMessage;</code></pre>
<p>We will just use the following code, however, as it sets the message's response to the default <code>()</code> and the message's ID to its full module path (in this case, <code>project_name::MyMessage</code>):</p>
<pre><code class="language-rust">#[message]
struct Mymessage;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-messages-defining-and-sending-messages"><a class="header" href="#handling-messages-defining-and-sending-messages">Handling Messages# Defining and Sending Messages</a></h1>
<p>Implementing a message handler on an actor is relatively simple:</p>
<pre><code class="language-rust">use fluxion::Handler;

impl Handler&lt;MyMessage&gt; for MyActor {
    async fn handle_message&lt;D: Delegate&gt;(&amp;self, message: TestMessage, context: &amp;ActorContext&lt;D&gt;) {
        println!(&quot;{:?} received by {}&quot;, message, context.get_id());
    }
}
</code></pre>
<p>Message handlers have access to the message, and to a context that provides information about the current actor, as well as access to the system to create more actors and send further messages.</p>
<p>Sending a message is pretty simple. Using the local handle we previously retrieved, we can send any message type that is handled by the actor:</p>
<pre><code class="language-rust">use fluxion::MessageSender;

actor_ref.send(MyMessage).await;</code></pre>
<p>We do not need to unwrap this call, because message sending will never error, and just returns the type dictated by the message's result. In this case, we used <code>()</code>.</p>
<p>Now we can also retrieve a <code>MessageSender</code>, which can only send a specific message type:</p>
<pre><code class="language-rust">let actor_ref = system.get::&lt;MyActor, MyMessage&gt;(id).await.unwrap();
actor_ref.send(MyMessage).await;</code></pre>
<p>We will look closer at <code>MessageSender</code>s when we get to foreign messages in the future. Our final code for this section, with thorough comments, can be found in the <code>simple</code> example on github.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-messages"><a class="header" href="#foreign-messages">Foreign Messages</a></h1>
<p>This section has not yet been developed. A (still rather rough) example of foreign messages can be found in the <code>foreign</code> example. It requires both the <code>serde</code> and the <code>foreign</code> feature flags to compile. The example just uses <code>slacktor</code> as a basic method to communicate between two delegates, however any other mechanism will work (IPC pipes, sockets, even a serial port), as long as you can implement request/response semantics on top of it.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
